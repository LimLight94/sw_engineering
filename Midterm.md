# 중간고사 정리
- o,x문제
- 빈칸 채우기
- 단답형
- 서술형 (어떤것과 어떤것의 차이를 서술하라 1,2줄)
# 목차
  - ### [1.Introduction](#introduction)
  - ### [2.SW_Processes](#sw-processes)
  - ### [3_1.Critical System](#critical-system)
  - ### [3_2.Agile SW](#agile-sw)
  - ### [4.Requirements](#requirements)  
  - ### [5.System modeling](#system-modeling)  


# Introduction
  - 작성필요
# SW Processes
  - Specification : 요구사항 정의
  - Design and implementation(설계 및 구현) : 시스템을 정의하고 구현
  - Validation(검증) : 요구를 수행하는지 확인
  - Evolution : 고객 변경 요구에 대한 시스템 변경
  - Plan-driven processes
    - 프로세스 활동을 미리 계획하고 진행률을 측정하는 프로세스
    - 실제로 현업에선 aglie 과 plan-driven 모두 사용한다.
  - SW processes model
    - waterfall model
      - plan-driven model 이며 개발과 계획을 분리한다.
      - 요구분석및 정의 / 구현 및 단위테스트 / 통합 및 시스템테스트 / 운영 및 유지보수
      - 장점
        - 대규모의 프로젝트에서 사용하기 용이함
        - 요구사항이 잘 정리되고 설계 과정에서의 변경이 제약적인경우
      - 단점
        - 프로세스가 진행된후의 변경이 어렵다.
        - 원칙적으로 다음단계로 이동하려면 전단계가 완료되어야한다.
    - incrementeal model
      - 개발과 계획이 뒤얽혀 있다 plan-driven 과 agile의 결합
      - 장점
        - 변화를 수용하기가 훨씬 간편하다
        - 고객의 피드백을 받기 쉽다
        - 고객에게 신속하게 배포할 수 있다.
      - 단점
        - 관리자 입장에서 프로세스의 진행도를 알기 어렵다.
        - 꾸준한 변경으로 인해 추후에 리팩토링 하기가 어렵다.
    - integration and configuration
      - 기존 컴포넌트들을 조합하여 개발 plan-driven 과 agile의 결합
      - .NET or J2EE 같은 프레임워크로 개발된 개체에 사용됨
      - Stand-alone application systems (sometimes called COTS) 라고 부름
    - Reuse-oriented sw engineering
      - 다음과 같은 순서로 처리됨
      - Requirements specification/Software discovery and evaluation/Requirements refinement/Application system configuration/Component adaptation and integration
      - 장점
        - 처음부터 개발되는 소프트웨어가 줄어 비용 및 위험 감소
        - 배포 속도 향상
      - 단점
        - 사용자의 요구사항에 충족 못할수 있음
        - 재사용될 시스템 진화를 통제할수 없음    
  - Process activities
    - Architectural design : 주요 구성요소(모듈),컴포넌트 들의 관계 및 분배 방법 설계
    - Database design : 시스템 데이터구조를 디자인 하고 db로 어떻게 표현되는지
    - Interface design : 컴포넌트들 사이의 인터페이스를 정의함
    - Component selection and design : 재사용 가능한 컴포넌트를 찾고 없는 경우 설계
    - Verification and validation (V & V) : 시스템이 사양을 만족하는지 확인하기위함
  - Coping with change
    - prototyping 전달
      - 장점
        - 시스템 사용성 up
        - 갑의 니즈에 더욱 가깝게
        - 디자인 퀄리티 up
        - 유지보수성 up
        - 개발노력을 줄일수 있다.
    - increments delivery :  우선순위를 정하여 높은 우선순위 부터 개발하여 전달
      - 장점
        - 각 기능마다 고객 에게 제공하므로 시스템을 일찍 사용해 볼수 있다.
        - 초기에 전달되는 제품은 나중 요구사항을 위한 프로토타입이 될수 있다.
        - 프로젝트 실패 위험을 감소
        - 우선순위가 높은 서비스는 가장 많이 테스팅 해볼 수 있음
      - 단점
        - 기능단위별로 제공할수 있는 공통적인 시스템이 있어야 한다.
        - 기능이 구현될때까지 모든 요구사항이 자세히 정의 되자않으므로 공통 시스템을 식별 하기 어려움
        - 특정 specification 이 개발과 함께 구현되므로 전체 요구사항과 충돌이 날 수 있다.
# Critical System
  - System dependability (시스템 신뢰성)
    - Usefulness , trustworthiness are not same
    - 신뢰성이 낮다면 사용자가 거부하거나 , 높은 복구비용으로 손실을 야기함
    - 신뢰성의 분류
      - Survivability : 외부공격으로 정상유지됨
      - Availability : 요청한 결과를 가져다주는 확률
      - Reilability : 서비스가 명시된대로 수행될 확률
        - Reiliability terminology
          - System failure
            - 시스템이 사용자가 예상한 행동을 제공하지않는 상황
          - System error
            - system failure 로 이어질수 있는 잘못된 시스템 상태
          - System fault
            - error 를 일으 킬수 있는 상태 ex)변수 초기화의 실수
          - Human error or mistake : 인간의 실수 
        - perception of reliability (신뢰도의 인식)
          - 신뢰도 수준이 사용자 인식의 절대적 기준은 아님
          - 같은 신뢰도 수준이어도 와이퍼의 신뢰도와 엔진의 신뢰도는 사용자에게 신뢰의 가중치가 다름
        - 오류 방지 방법
          - 오류 감지 및 제거
          - 런타임 기술을 이용하여 system error 가 system failure 로 이어지지 않게 한다. 
      - Safety : 사람의 안전을 보장하는 시스템 속성
        - 스펙대로 행동하여 reiliable 하더라도 unsafy한 케이스 존재 Ex) 엘레베이터 문 닫힘
        - Safety terminology
          - Accident : 실제 일어난 사건
          - Hazard : 잠재적 위험상태
          - Damage : 손실율
      - Security : 시스템 자체를 보호하는 능력
        - 데이터의 손상,기밀정보의 공개 를 야기
        - assurance
          - 취약성 회피 ex)인트라넷
          - 공격 탐지 및 제거 ex)바이러스 검사
          - 손상된 정보를 복원 하도록 ex) 백업
# Agile SW
  - 개요 및 특징
    - 1990년대 후반 개발 시간을 대폭 단축하기 위해 등장한 방법론
    - 평가를 위한 새로운 버전을 delivert
    - 개발을 돕기위한 자동화 테스트도구 사용
    - 문서를 최소하하고 코드에 집중
    - 과도한 재작업 없이 변경된 요구사항에 신속히 대응
    - 고객이 개발프로세스에 참여
  - Plan-driven 과 agile 의 차이점
    - requirements specification(요구사항 정의) 단계를 없앰
  - Agile methods
    - Customer involvement(고객참여)
      - 고객은 개발프로세스에 참여하고 요구사항의 우선순위를 정하고 평가함
    - Embrace change(변화 수용)
      - 변경될 요구사항을 예상하고 수용하도록 설계
    - Maintain simplicity(단순성 유지)
      - 시스템의 복잡성을 제거하기 위해 노력
  - Agile dvelopment techniques
    - XP(Extreme Programming)
      - 새버전은 하루에도 여러번 빌드될수 있음
      - 고객에게 2주마다 sw 제공
      - 모든 빌드에 대하여 테스트 적용, 성공시 빌드 승인
    - On-site customer
      - xp개발팀의 구성원으로서 여러고객의 입장을 대표함
    - 소규모의 릴리즈를 통해 점진적 개발
    - 지속적인 리팩토링을 통해 단순성 유지
    - pair 프로그래밍
      - 팀원이 퇴사시에 전반적인 위험을 줄여줌
      - 항상 효율적인것은 아님
    - 사용자의 요구사항은 스토리 or 시나리오 카드로 표현
    - Test-driven development
      - 구현전 테스트 코드를 작성 : 요구사항이 명확해짐
      - 테스트 자동화 구현 ex) JUnit
      - 기능추가시 이전 모든 테스트가 실행됬으므로 새기능의 오류를 확인가능
      - 테스트는 항상 완벽할수 없음
      - diplay 단 로직,화면간의 워크플로우에 대한 unit테스트 작성 어려움
  - Agile project management
    - Scrum : 반복적인 개발관리에 초점을 맞춘 agile 방법
      - 초기단계에 일반적인 목표를 설정,아키텍쳐 설계
      - followed by a series of sprint cycles, where each cycle develops an increment of the system
      - 프로젝트를 마무리하고 필수문서를 작성하여 프로젝트를 평가함
    - Scrum terminology
      - Product backlog : 프로젝트 Toto list
      - Srum : 스크럼팀의 짧은 일일 회의
      - ScrumMaster : 효율적으로 팀을 안내 팀은 고객과 격리되어 외부 커뮤니케이션은 master를 통해전달
      - Sprint : 개발 반복 주기 통상 2주~4주
    - Scrum 장점
      - 제품은 관리 및 이해가능한 단위로 세분화됨
      - 불안정한 요구사항으로 진행이 방해되지 않음
      - 고객은 제때 제품을 받아보고 작동방식에 대한 피드백을 주고받을수 있다.
      - 고객 과 개발자간 신뢰가 확립됨
  - Scaling aglie methods 
    - scaling up : 작은 팀에서 개발할수 없는 큰 소프트웨어를 개발할때 적용
    - scaling out : 큰조직에서도 agile 을 적용할 수 있도록
    - 문제점
      - 큰규모회사의 경우 formal 한 형태로 개발하기 떄문에 agile 하기 어려움
      - agile은 새로운 소프트웨어를 만들때 용이함 , but 큰 회사의경우 유지보수에 많은 비용을 사용
      - 문서부족으로 유지보수가 어려움
# Requirements
  - User requirements
    - 자연어로 된 설명으로 제공하는 서비스 및 운영상의 제약을 나타내는 다이어그램 (고객을 위한)
  - System requirements
    - 서비스 기능 및 운영 제약 에 대한 구체적으로 구조화된 문서 계약의 일부가됨
  - Functional and non-functional requirements 
  - Requirements engineering processes 
  - Requirements elicitation
  - Requirements specification 
  - Requirements validation
  - Requirements change
# System modeling
  - 특징
    - system modeling 은 추상적인 모델 프로세스
    - UML 을 이용하여 그래픽으로 모델링
    - 고객의 요구사항을 이해하는데 도움
  - Context models
    - 시스템 외부와 내부의 관계를 보여줌
    - 세부적인 방식이 아닌 다른 시스템 들과의 관계를 보여줌
  - Interaction models
    - use case modeling
      - 유즈 케이스 하나당 하나의 태스크를 표현
    - sequence diagrams
      - 순차적으로 일어나는 인터렉션을 수직적으로 표현
  - Structural models
    - 시스템 아키텍쳐를 논의하는 모델, 구성요소관점에서 시스템의 구성을 보여줌
    - Class Diagram
      - 객체지향 시스템 모델을 개발할때 사용
      - 클래스 간의 관계를 1:1 1:N 등으로 나타냄
    - Generalization
      - 객체지향의 상속 개념과 일치하도록
      - 모델을 일반화하여 상위 하위 개념으로 나눔
    - Obejct aggregation(객체 집합)
      - 컬렉션인 클래스가 어떤 클래스들로부터 구성되어있는지 나타내줌
  - Behavioral models
    - 자극(이벤트) 로인하여 동적으로 동작되는 모델을 나타냄
    - Data-driven modeling
      - 상대적으로 외부이벤트가 아닌 시스템에서 입력되는 데이터에 의해 제어됨
      - 데이터 처리및 관련 출력 생성의 작업을 보여줌
    - Event-driven modeling
      - 외부 및 내부 이벤트에 어떻게 반응하는지 보여줌
      - State machine models
        - 자극에 대한 시스템 반응을 보여줌
        - 시스템 상태를 노드 , 이벤트를 노드사이의 원으로 보여줌
        - UML 의 필수 요소